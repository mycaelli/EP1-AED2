
//está retornando o erro: signal: segmentation fault (core dumped)
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <limits.h> 
#include <stdbool.h>


int grupo() {
  return 0;
}

// ######### ESCREVA O NROUSP AQUI
int nroUSP1() {
    return 0;
}

int nroUSP2() {
    return 0;
}

// elemento das listas de adjacÍncia e de resposta - NAO ALTERE ESTA DEFINICAO
typedef struct estr 
{
    int adj; // elemento
	  int peso; // custo (n„o precisa ser usado na resposta)
    struct estr *prox;
} NO;

// vertices do grafo (salas) - use este tipo ao criar o grafo  - NAO ALTERE ESTA DEFINICAO
typedef struct 
{
    int flag; // para uso na busca em largura e profundidade, se necessario
    bool aberto; // vale true se a sala em questao esta aberta
    int via; // use este campo se precisar computar algum caminho etc.
	  int dist; // use este campo se precisar computar alguma dist‚ncia etc.
    NO* inicio;
} VERTICE;

/*
	funcao cria N vertices
	inicializa seus campos com 0
	define se o vertice esta aberto ou fechado a partir do array estaAberto
*/
VERTICE *criaVertices(int N, int *estaAberto) {
	VERTICE *g = (VERTICE *) malloc(sizeof(VERTICE) * N);
	for (int i = 0; i < N; i++) {
		g[i].flag = 0;
		g[i].via = 0;
		g[i].dist = INT_MAX;
		g[i].inicio = NULL;
		//aberto[i] = estaAberto[i]; essa linha estava dando erro
    g[i].aberto = estaAberto[i];
	}
	return g;
}

/*
	funcao que insere as arestas no grafo
	ex primeira chamada -> i = 0
		origem = ijpeso[0 * 3]
		destino = ijpeso[0 * 3 + 1]
		peso = ijpeso[0 * 3 + 2]

*/
void insereArestas(VERTICE *g, int origem, int destino, int peso) {
	//int origem = ijpeso[atual*3];
	//int destino = ijpeso[atual*3+1];
	//int peso = ijpeso[atual*3+2];

	NO *novoNo = (NO*)malloc(sizeof(NO));
	novoNo->adj = destino;
	novoNo->peso = peso;
	novoNo->prox = g[origem].inicio;
	g[origem].inicio = novoNo;
}

/*
	N = Grafo de N vertices
	A = Grafo de A arestas
	*ijpeso = Representa as arestas (tamanho 3 * A)
		ex: A = 2, ijpeso={1,2,3,4,5,6}
			grafo g possui uma aresta entre os vertices 1 e 2 com peso 3
			e possui uma aresta entre os vertices 4 e 5 com peso 6
	*aberto = indica se os vertices estao abertos ou fechados
		- contem apenas valores 0 ou 1
	inicio, fim = busca
	chave = vertice chave
*/

int encontraMenorDistancia(VERTICE *g, int N) {
    int min = INT_MAX;
	  int min_idx;

    for (int i = 0; i < N; i++) {
		    if (g[i].flag == 0 && g[i].dist <= min) {
			     min = g[i].dist;
			     min_idx = i;
		    }
	  }
	return min_idx;
}

// funcao principal
NO *caminho(int N, int A, int *ijpeso, int *aberto, int inicio, int fim, int chave){
  NO* resp;
	resp = NULL;
	bool temChave = false;
  
	VERTICE* g = criaVertices(N, aberto);

	for (int i = 0; i < A; i++) {
      int origem = ijpeso[i * 3];
      int destino = ijpeso[i * 3 + 1];
      int peso = ijpeso[i * 3 + 2];
      insereArestas(g, destino, origem, peso);
	 }
	//...

	/*dist da origem pra ela mesma*/
	g[inicio].dist = 0; 

	for (int i = 0; i < N; i++) {
		int u = encontraMenorDistancia(g, N);
    g[u].flag = 1;
    
    NO *adjacente =g[u].inicio;
    while (adjacente != NULL){ //percorre os adjacentes a u
      int w = adjacente->adj;
      int peso = adjacente->peso;
      if (g[w].flag == 0 && g[u].dist + peso < g[w].dist){ //verifica se o custo p ir de um p outtro é menor do q o q esta acumulado
        g[w].via = u; //caso seja, ele atualiza indicando q o u é um vertice do caminho
        g[w].dist = g[u].dist + peso; //atualiza o custo acumulado
      }
      if (w == chave && g[u].dist <= g[w].dist){
        temChave = true; //ve se o vértice é= a chave e casoo custo para ir de u a v é menor ou igual ao custo ja acumulado. se for, o caminho até v pode incluir a passagem pela chave e temChave é definido como verdadeiro.
      }
      adjacente = adjacente ->prox;
    }
  }
  if (temChave) {
    int sAtual = fim;
    while (sAtual != inicio){
      NO *novoNo = (NO *)malloc(sizeof(NO));
      novoNo->adj = sAtual;
      novoNo->prox = resp;
      resp = novoNo;

      sAtual = g[sAtual].via;
    }
  }
		
	return resp;
}

/*
	encontra o vertice nao visitado com menor dist 
*/


//---------------------------------------------------------
// use main() para fazer chamadas de teste ao seu programa
//---------------------------------------------------------
int main()
{
    int N = 6;                                         // 
    int A = 7;                                         // 

    int ijpeso[] = {1, 2, 2, 1, 3, 4, 2, 3, 1, 3, 4, 2, 4, 5, 3, 5, 6, 2};
    int aberto[] = {1, 1, 1, 1, 0, 1};                    // 
    int inicio = 1;                                     // 
    int fim = 6;                                        // 
    int chave = 3;                                      // 

    NO *resultado = caminho(N, A, ijpeso, aberto, inicio, fim, chave);

    if (resultado == NULL)
    {
        printf("Não foi possível encontrar um caminho válido.\n");
    }
    else
    {
        printf("Caminho de menor custo:\n");
        while (resultado != NULL)
        {
            printf("%d ", resultado->adj);
            resultado = resultado->prox;
        }
        printf("\n");
    }

    return 0;
}
